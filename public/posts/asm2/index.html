<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PicoCTF: ASM2 | 0xtaxyneno</title>
<meta name=keywords content="picoctf,asm"><meta name=description content="Learning how function arguments are referenced in assembly. Fun!"><meta name=author content="David"><link rel=canonical href=http://localhost:1313/posts/asm2/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/asm2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="PicoCTF: ASM2"><meta property="og:description" content="Learning how function arguments are referenced in assembly. Fun!"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/asm2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-09T00:00:00+00:00"><meta property="og:site_name" content="0xTaxyneno"><meta name=twitter:card content="summary"><meta name=twitter:title content="PicoCTF: ASM2"><meta name=twitter:description content="Learning how function arguments are referenced in assembly. Fun!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"PicoCTF: ASM2","item":"http://localhost:1313/posts/asm2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PicoCTF: ASM2","name":"PicoCTF: ASM2","description":"Learning how function arguments are referenced in assembly. Fun!","keywords":["picoctf","asm"],"articleBody":" Problem Overview In ASM2, we are given assembly source code to reverse engineer. We know that the function takes two arguments: 0x4 and 0x2d\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 asm2: \u003c+0\u003e:\tpush ebp \u003c+1\u003e:\tmov ebp,esp \u003c+3\u003e:\tsub esp,0x10 \u003c+6\u003e:\tmov eax,DWORD PTR [ebp+0xc] \u003c+9\u003e:\tmov DWORD PTR [ebp-0x4],eax \u003c+12\u003e:\tmov eax,DWORD PTR [ebp+0x8] \u003c+15\u003e:\tmov DWORD PTR [ebp-0x8],eax \u003c+18\u003e:\tjmp 0x50c \u003c+20\u003e:\tadd DWORD PTR [ebp-0x4],0x1 \u003c+24\u003e:\tadd DWORD PTR [ebp-0x8],0xd1 \u003c+31\u003e:\tcmp DWORD PTR [ebp-0x8],0x5fa1 \u003c+38\u003e:\tjle 0x501 \u003c+40\u003e:\tmov eax,DWORD PTR [ebp-0x4] \u003c+43\u003e:\tleave \u003c+44\u003e:\tret I had to learn how function arguments are managed on the stack, and it wasn't that bad! Before we walk through the assembly code and get the flag, let's explore arguments and the stack.\nArguments and the Stack… Coming from a background of higher-level languages, I never really had to wonder how arguments in code like below was represented in assembly:\n1 2 def check_number(first, second): return first + second This is a good chance to learn! Let's see what fancy stuff is going on in the code.\nCreating a New Stack Frame The below sequence is a commonly-found sequence for many compilers. The push and mov instructions sets up a new stack frame.\nThe sub instruction creates space in memory for automatic local variables. You can read about this sequence here.\n1 2 3 4 asm2: \u003c+0\u003e:\tpush ebp \u003c+1\u003e:\tmov ebp,esp \u003c+3\u003e:\tsub esp,0x10 ;; 16 bytes Now, we have a new stack frame with 16 bytes of memory allocated.\nAccessing Function Parameters I found out that there are different conventions for how arguments are passed onto the stack.\nThe assembly code looked like x86, so I assumed it was using the cdecl calling convention.\nIn cdecl, functions arguments are passed onto the stack from right to left.\nSo in the example below, the assembly representation would first push `num3` onto the stack, then `num2`, and finally `num1`.\n1 2 3 int add(int num1, int num2, int num3) { return num3 + num2 + num1; } For our CTF challenge, we now know that the last function parameter is the first thing pushed onto the stack.\nGetting the 2nd Parameter For this code segment, we get the value 12 bytes above ebp, the 2nd paramter, and push it into eax.\nAfterwards, we move the value from eax 4 bytes below ebp, making it easier to call in our stack frame.\nWe know that the 2nd paramter is 0x2d, or 45.\n1 2 \u003c+6\u003e:\tmov eax,DWORD PTR [ebp+0xc] \u003c+9\u003e:\tmov DWORD PTR [ebp-0x4],eax Getting the 1st Parameter Likewise, we repeat the same process to get the first function parameter, 0x4, into the stack frame.\n1 2 \u003c+12\u003e:\tmov eax,DWORD PTR [ebp+0x8] ;; \u003c+15\u003e:\tmov DWORD PTR [ebp-0x8],eax ;; Simple Calculations Now that we know where our function parameter values are, we are left with a relatively straight-forward algorithm to follow:\n1 2 3 4 5 6 7 8 \u003c+18\u003e:\tjmp 0x50c \u003c+20\u003e:\tadd DWORD PTR [ebp-0x4],0x1 \u003c+24\u003e:\tadd DWORD PTR [ebp-0x8],0xd1 \u003c+31\u003e:\tcmp DWORD PTR [ebp-0x8],0x5fa1 \u003c+38\u003e:\tjle 0x501 \u003c+40\u003e:\tmov eax,DWORD PTR [ebp-0x4] \u003c+43\u003e:\tleave \u003c+44\u003e:\tret The algorithm is something like:\nIf the first function parameter is less than or equal to 24481\nAdd 1 to the second function parameter Add 209 to the first function parameter Return to the less than or equal comparison If the first function parameter is \u003e 24481, move the second function parameter into eax\nReturn the value in eax More or less, we can translate the assembly code here into this simple Python script:\n1 2 3 4 5 6 7 8 9 10 arg_1 = 4 arg_2 = 45 counter = 0 while arg_1 \u003c= 24481: arg_2 += 1 arg_1 += 209 counter += 1 print(f\"looped {counter} times, arg1: {arg_1}, arg2: {arg_2}\") Running the Python Script When we run the Python script, the output is: looped 118 times, arg1: 24666, arg2: 163\nWe know that the function returns the value of arg2, so the flag is simply the hexadecimal representation of 163, or 0xA3\n","wordCount":"688","inLanguage":"en","datePublished":"2024-09-09T00:00:00Z","dateModified":"2024-09-09T00:00:00Z","author":{"@type":"Person","name":"David"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/asm2/"},"publisher":{"@type":"Organization","name":"0xtaxyneno","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="0xTaxyneno (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>0xTaxyneno</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PicoCTF: ASM2</h1><div class=post-meta><span title='2024-09-09 00:00:00 +0000 UTC'>September 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;David</div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Problem Overview</h2><div id=outline-text-headline-1 class=outline-text-2><p>In ASM2, we are given assembly source code to reverse engineer. We know that the function takes two arguments: <code class=verbatim>0x4</code> and <code class=verbatim>0x2d</code></p><div class="src src-assembly"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>asm2:
</span></span><span class=line><span class=cl>	&lt;+0&gt;:	push   ebp
</span></span><span class=line><span class=cl>	&lt;+1&gt;:	mov    ebp,esp
</span></span><span class=line><span class=cl>	&lt;+3&gt;:	sub    esp,0x10
</span></span><span class=line><span class=cl>	&lt;+6&gt;:	mov    eax,DWORD PTR [ebp+0xc]
</span></span><span class=line><span class=cl>	&lt;+9&gt;:	mov    DWORD PTR [ebp-0x4],eax
</span></span><span class=line><span class=cl>	&lt;+12&gt;:	mov    eax,DWORD PTR [ebp+0x8]
</span></span><span class=line><span class=cl>	&lt;+15&gt;:	mov    DWORD PTR [ebp-0x8],eax
</span></span><span class=line><span class=cl>	&lt;+18&gt;:	jmp    0x50c &lt;asm2+31&gt;
</span></span><span class=line><span class=cl>	&lt;+20&gt;:	add    DWORD PTR [ebp-0x4],0x1
</span></span><span class=line><span class=cl>	&lt;+24&gt;:	add    DWORD PTR [ebp-0x8],0xd1
</span></span><span class=line><span class=cl>	&lt;+31&gt;:	cmp    DWORD PTR [ebp-0x8],0x5fa1
</span></span><span class=line><span class=cl>	&lt;+38&gt;:	jle    0x501 &lt;asm2+20&gt;
</span></span><span class=line><span class=cl>	&lt;+40&gt;:	mov    eax,DWORD PTR [ebp-0x4]
</span></span><span class=line><span class=cl>	&lt;+43&gt;:	leave
</span></span><span class=line><span class=cl>	&lt;+44&gt;:	ret</span></span></code></pre></td></tr></table></div></div></div><p>I had to learn how function arguments are managed on the stack, and it wasn't that bad! Before we walk through the assembly code and get the flag, let's explore arguments and the stack.</p></div></div><div id=outline-container-headline-2 class=outline-2><h2 id=headline-2>Arguments and the Stack…</h2><div id=outline-text-headline-2 class=outline-text-2><p>Coming from a background of higher-level languages, I never really had to wonder how arguments in code like below was represented in assembly:</p><div class="src src-python3"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python3 data-lang=python3><span class=line><span class=cl><span class=k>def</span> <span class=nf>check_number</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>second</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>first</span> <span class=o>+</span> <span class=n>second</span></span></span></code></pre></td></tr></table></div></div></div><p>This is a good chance to learn! Let's see what fancy stuff is going on in the code.</p><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Creating a New Stack Frame</h3><div id=outline-text-headline-3 class=outline-text-3><p>The below sequence is a commonly-found sequence for many compilers. The <code class=verbatim>push</code> and <code class=verbatim>mov</code> instructions sets up a new stack frame.</p><p>The <code class=verbatim>sub</code> instruction creates space in memory for <a href=https://en.wikipedia.org/wiki/Automatic_variable>automatic local variables</a>. You can read about this sequence <a href=https://en.m.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames>here</a>.</p><div class="src src-assembly"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>asm2:
</span></span><span class=line><span class=cl>	&lt;+0&gt;:	push   ebp
</span></span><span class=line><span class=cl>	&lt;+1&gt;:	mov    ebp,esp
</span></span><span class=line><span class=cl>	&lt;+3&gt;:	sub    esp,0x10 ;; 16 bytes</span></span></code></pre></td></tr></table></div></div></div><p>Now, we have a new stack frame with 16 bytes of memory allocated.</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Accessing Function Parameters</h3><div id=outline-text-headline-4 class=outline-text-3><p>I found out that there are different conventions for how arguments are passed onto the stack.</p><p>The assembly code looked like x86, so I assumed it was using the <code class=verbatim>cdecl</code> <a href=https://bugaevc.github.io/asmwall/?cdecl>calling convention</a>.</p><p>In cdecl, functions arguments are passed onto the stack from right to left.</p><p>So in the example below, the assembly representation would first push `num3` onto the stack, then `num2`, and finally `num1`.</p><div class="src src-c"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>num1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>num2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>num3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>num3</span> <span class=o>+</span> <span class=n>num2</span> <span class=o>+</span> <span class=n>num1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div><p>For our CTF challenge, we now know that the last function parameter is the first thing pushed onto the stack.</p><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>Getting the 2nd Parameter</h4><div id=outline-text-headline-5 class=outline-text-4><p>For this code segment, we get the value 12 bytes above ebp, the 2nd paramter, and push it into eax.</p><p>Afterwards, we move the value from eax 4 bytes below ebp, making it easier to call in our stack frame.</p><p>We know that the 2nd paramter is <code class=verbatim>0x2d</code>, or 45.</p><div class="src src-assembly"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	&lt;+6&gt;:	mov    eax,DWORD PTR [ebp+0xc]
</span></span><span class=line><span class=cl>	&lt;+9&gt;:	mov    DWORD PTR [ebp-0x4],eax</span></span></code></pre></td></tr></table></div></div></div></div></div><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>Getting the 1st Parameter</h4><div id=outline-text-headline-6 class=outline-text-4><p>Likewise, we repeat the same process to get the first function parameter, <code class=verbatim>0x4</code>, into the stack frame.</p><div class="src src-assembly"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	&lt;+12&gt;:	mov    eax,DWORD PTR [ebp+0x8] ;;
</span></span><span class=line><span class=cl>	&lt;+15&gt;:	mov    DWORD PTR [ebp-0x8],eax ;;</span></span></code></pre></td></tr></table></div></div></div></div></div></div></div></div></div><div id=outline-container-headline-7 class=outline-2><h2 id=headline-7>Simple Calculations</h2><div id=outline-text-headline-7 class=outline-text-2><p>Now that we know where our function parameter values are, we are left with a relatively straight-forward algorithm to follow:</p><div class="src src-assembly"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	&lt;+18&gt;:	jmp    0x50c &lt;asm2+31&gt;
</span></span><span class=line><span class=cl>	&lt;+20&gt;:	add    DWORD PTR [ebp-0x4],0x1
</span></span><span class=line><span class=cl>	&lt;+24&gt;:	add    DWORD PTR [ebp-0x8],0xd1
</span></span><span class=line><span class=cl>	&lt;+31&gt;:	cmp    DWORD PTR [ebp-0x8],0x5fa1
</span></span><span class=line><span class=cl>	&lt;+38&gt;:	jle    0x501 &lt;asm2+20&gt;
</span></span><span class=line><span class=cl>	&lt;+40&gt;:	mov    eax,DWORD PTR [ebp-0x4]
</span></span><span class=line><span class=cl>	&lt;+43&gt;:	leave
</span></span><span class=line><span class=cl>	&lt;+44&gt;:	ret</span></span></code></pre></td></tr></table></div></div></div><p>The algorithm is something like:</p><ol><li><p>If the first function parameter is less than or equal to <code class=verbatim>24481</code></p><ol><li>Add 1 to the second function parameter</li><li>Add 209 to the first function parameter</li><li>Return to the less than or equal comparison</li></ol></li><li><p>If the first function parameter is > <code class=verbatim>24481</code>, move the second function parameter into eax</p><ol><li>Return the value in eax</li></ol></li></ol><p>More or less, we can translate the assembly code here into this simple Python script:</p><div class="src src-python"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>arg_1</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>arg_2</span> <span class=o>=</span> <span class=mi>45</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>arg_1</span> <span class=o>&lt;=</span> <span class=mi>24481</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>arg_2</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>arg_1</span> <span class=o>+=</span> <span class=mi>209</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;looped </span><span class=si>{</span><span class=n>counter</span><span class=si>}</span><span class=s2> times, arg1: </span><span class=si>{</span><span class=n>arg_1</span><span class=si>}</span><span class=s2>, arg2: </span><span class=si>{</span><span class=n>arg_2</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div></div><div id=outline-container-headline-8 class=outline-2><h2 id=headline-8>Running the Python Script</h2><div id=outline-text-headline-8 class=outline-text-2><p>When we run the Python script, the output is:
<code class=verbatim>looped 118 times, arg1: 24666, arg2: 163</code></p><p>We know that the function returns the value of arg2, so the flag is simply the hexadecimal representation of 163, or <code class=verbatim>0xA3</code></p></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/picoctf/>Picoctf</a></li><li><a href=http://localhost:1313/tags/asm/>Asm</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/asm1/><span class=title>Next »</span><br><span>PicoCTF: ASM1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>0xtaxyneno</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>